# Audit Technique - Le "Patient Zéro" (Token vs ID)

**Date :** 26 Janvier (Session 2)
**Sujet :** Analyse du blocage critique sur le Matchmaking Nakama et le Bridge Godot.

## 1. Le Problème "Patient Zéro"

Le blocage actuel réside dans une incompatibilité fondamentale ("Design Flaw") entre trois éléments de la stack technique :

1.  **Le Serveur Nakama :** Génère des Match IDs avec un point final (ex: `...e5e1.`) dans cette configuration, et exige un **Token** pour rejoindre les matchs issus du Matchmaker.
2.  **Le SDK Nakama (Client) :** Utilise une détection automatique ("Heuristique") dans `join_match_async` pour distinguer ID et Token. La règle est : *"Si la chaîne contient un point (.), c'est un Token. Sinon, c'est un ID."*
3.  **L'Addon Godot (Bridge) :** Est une surcouche simplifiée qui masque la complexité de la connexion. Il stocke l'argument passé à `join_match()` comme étant l'ID de référence du match.

### Le Cercle Vicieux
*   **Scénario A : On donne l'ID au Bridge (`...e5e1.`)**
    *   L'ID contient un point.
    *   Le SDK croit à tort que c'est un Token.
    *   Il l'envoie au serveur dans le champ `token`.
    *   **Résultat :** Rejet Serveur ("Invalid Match ID" car le token est malformé).

*   **Scénario B : On donne le Token au Bridge (`eyJ...`)**
    *   Le SDK voit les points, identifie correctement le Token.
    *   La connexion réussit au niveau Socket ✅.
    *   **MAIS** le Bridge enregistre ce Token comme étant l'ID du match (`bridge.match_id = token`).
    *   Quand le serveur envoie ensuite des événements (ex: "Joueur 2 a rejoint le match `...e5e1.`"), le Bridge compare l'ID reçu avec son ID stocké.
    *   `Token != ID` -> Le Bridge ignore l'événement.
    *   **Résultat :** Connexion "Zombie" (Socket connecté, mais Jeu multijoueur inerte).

## 2. Historique des Tentatives

Nous avons exploré plusieurs voies pour contourner ce défaut sans succès propre :

### Tentative 1 : "Double Join" (Approche Naïve)
*   *Méthode :* `NakamaManager` rejoint manuellement, puis `NetworkManager` demande au Bridge de rejoindre.
*   *Échec :* Le Bridge tente une 2ème connexion réseau qui échoue (car déjà connecté) ou corrompt l'état.

### Tentative 2 : "Injection Manuelle" (Bricolage Option B)
*   *Méthode :* `NakamaManager` rejoint manuellement. On instancie le Bridge sans appeler sa fonction `join_match()`, en espérant lui injecter le socket déjà prêt.
*   *Échec :* Le Bridge a besoin de connaître son propre ID utilisateur (`_self_id`) pour calculer son PeerID Godot. Cette variable est privée et non initialisée si on saute `join_match()`.
*   *Erreur :* `Invalid assignment of property '_self_id'`.

### Tentative 3 : "Passage du Token" (Scénario B ci-dessus)
*   *Méthode :* On donne le Token à `join_match()`.
*   *Échec :* Le Bridge est connecté mais "sourd" car il écoute sur le mauvais ID (le Token).

### Tentative 4 : "Recovery Strategy" (Proposée mais rejetée)
*   *Méthode :* On laisse le Bridge échouer ou se tromper, on intercepte l'erreur/le signal, et on écrase brutalement son `match_id` interne avec le bon ID.
*   *Statut :* Fonctionnel techniquement ("Dirty Fix"), mais rejeté car considéré comme du bricolage instable.

## 3. Solutions Restantes

Puisque nous refusons le "bricolage" externe (Tentative 4), il ne reste que des solutions structurelles :

### Solution A : Modifier l'Addon (Fork Local)
C'est la solution la plus propre techniquement. Au lieu de contourner le code de l'addon depuis l'extérieur, nous modifions le script de l'addon (`addons/com.heroiclabs.nakama/.../NakamaMultiplayerBridge.gd`).
*   **Action :** Ajouter une méthode publique `set_match_id(id)` ou rendre `_self_id` public (`@public`).
*   **Avantage :** Code du jeu reste propre. On corrige l'outil.
*   **Inconvénient :** Si on met à jour l'addon via l'AssetLib, on perd la modif (mais peu probable à court terme).

### Solution B : Abandonner le Matchmaker (Target Architecture)
Le problème est spécifique aux matchs créés par le Matchmaker (qui imposent un Token).
*   **Action :** Passer directement à l'architecture "Host/Join" (QR Code) prévue pour la version finale. L'Host crée un match (`create_match`), obtient un ID pur. Le client rejoint via cet ID.
*   **Avantage :** Plus de Token, plus d'ambiguïté, le Bridge marche "out of the box".
*   **Inconvénient :** On perd la recherche d'adversaire aléatoire (Matchmaking).

## Recommandation
Si l'objectif final est le jeu par invitation (QR Code), la **Solution B** est la plus saine : elle élimine la complexité inutile du Matchmaker qui cause ce bug.
Sinon, la **Solution A** (modifier l'addon) est requise.