# Audit Technique - Module Réseau (Nakama)

**Date :** 26 Janvier
**Sujet :** Analyse des dysfonctionnements du SDK Nakama et justification des "bricolages" (Custom Classes).

## 1. Le Constat
Nous sommes actuellement obligés d'utiliser des solutions de contournement (Workarounds) lourdes pour des tâches basiques :
1.  **Instanciation manuelle du Socket** (`NakamaSocketScript.new(...)`) au lieu de passer par le singleton.
2.  **Construction manuelle des messages** (`MatchJoin.new()`) au lieu d'utiliser les fonctions helper (`join_match_async`).
3.  **Imports manuels** (`preload("res://...")`) au lieu d'utiliser les classes globales (`NakamaRTAPI`).

## 2. La Cause Racine : "ClassDB Corruption" & Versioning

Le problème ne vient pas de votre code, ni fondamentalement du serveur Nakama. Il s'agit d'un problème structurel lié à l'intégration du plugin dans Godot 4.

### A. Le problème des `class_name` dans Godot 4
Le SDK Nakama définit des classes globales via `class_name` (ex: `NakamaRTAPI`, `NakamaSocket`).
Cependant, Godot 4 a un bug connu (ou une limitation) avec les addons : parfois, le **ClassDB** (l'index des classes globales) ne se met pas à jour correctement, ou perd les références vers les scripts de l'addon.

**Conséquence :**
Quand le code officiel du SDK essaie de faire `NakamaSerializer.deserialize(...)`, il cherche la classe globale `NakamaRTAPI`. Si Godot a "oublié" cette classe globale, le SDK échoue silencieusement ou renvoie un objet générique (`NakamaAsyncResult`) au lieu de l'objet typé (`Match`).

**Pourquoi le bricolage ?**
En faisant des `preload("res://...")` manuels, nous forçons Godot à charger le script spécifique, contournant ainsi le système de classes globales défaillant.

### B. L'ambiguïté de `join_match_async`
La fonction officielle `socket.join_match_async(target)` est censée être "intelligente".
- Si `target` ressemble à un UUID -> Elle envoie un `match_id`.
- Si `target` contient des points (JWT) -> Elle envoie un `token`.

Dans votre cas, l'erreur `Invalid match ID` prouve que le SDK a envoyé votre Token dans le champ `match_id`.
Cela indique soit :
1.  Une version du SDK trop ancienne (v2.5) qui n'avait pas cette intelligence.
2.  Une version du SDK buggée où la détection de string échoue.

**Pourquoi le bricolage ?**
En construisant manuellement l'objet `MatchJoin` et en assignant `msg.token = ...`, nous garantissons que la donnée part dans le bon champ JSON, sans dépendre de la logique interne (défaillante) du SDK.

## 3. Analyse du fichier `NakamaManager.gd` actuel

Le code actuel est "sale" mais **robuste** dans ce contexte dégradé.

```gdscript
# On charge manuellement les scripts car Godot ne trouve pas les classes globales
const NakamaSocketScript = preload(".../NakamaSocket.gd")

# On recrée le socket à la main pour lui injecter NOS scripts préchargés
# Cela permet au socket de savoir comment désérialiser les réponses
socket = NakamaSocketScript.new(client._adapter, HOST, PORT, SCHEME)

# On construit le message à la main pour éviter que join_match_async ne se trompe de champ
var join_msg = NakamaRTMessageScript.MatchJoin.new()
```

## 4. Recommandations

Pour sortir de ce mode "bricolage" et revenir à une utilisation standard (`out of the box`), il faudrait :

1.  **Nettoyage Radical :**
    *   Supprimer le dossier `addons/com.heroiclabs.nakama`.
    *   Supprimer le dossier `.godot` (cache import).
    *   Réinstaller la **dernière version stable** du SDK (3.x) depuis l'AssetLib.
    *   Redémarrer Godot.
    *   Aller dans *Project Settings > Plugins* et s'assurer que Nakama est activé.

2.  **Si cela échoue encore :**
    *   C'est que le problème vient de l'environnement Godot spécifique. Dans ce cas, **garder le bricolage actuel** est la solution la plus pragmatique. Il fonctionne, il est stable, et il ne bloque pas la production du jeu (Phase 3).

**Conclusion :** Le code actuel est une "adaptation nécessaire" à un environnement de plugin instable.