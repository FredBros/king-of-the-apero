# Audit de Crise - √âchec de l'Int√©gration Nakama

**Date :** 26 Janvier (Session 3)
**Sujet :** Bilan de l'√©chec de l'impl√©mentation du Multijoueur (Matchmaking & Host/Join).
**Statut :** üõë PROJET EN PAUSE TECHNIQUE

## 1. Synth√®se de la Situation

Nous avons tent√© d'impl√©menter une architecture multijoueur P2P relay√©e via Nakama pour un jeu Godot 4.
Malgr√© une connexion r√©ussie au serveur (Authentification OK, Socket OK), nous sommes incapables d'√©tablir une session de jeu synchronis√©e via le `NakamaMultiplayerBridge`.

**Le sympt√¥me final :** Le client rejoint la partie, le Socket re√ßoit les √©v√©nements de pr√©sence (logs `joins: 1`), mais `multiplayer.get_peers()` reste vide. Le jeu reste bloqu√© sur "Waiting for players".

## 2. Chronologie des √âchecs

### Phase 1 : Le "Patient Z√©ro" (Matchmaking)
*   **Objectif :** Utiliser le Matchmaker pour trouver un adversaire.
*   **Le Probl√®me :** Conflit de format ID vs Token.
    *   Le serveur g√©n√®re des Match IDs finissant par un point (ex: `...e5e1.`).
    *   Le SDK Client (fonction `join_match_async`) interpr√®te tout string contenant un point comme un **Token** (JWT).
    *   **R√©sultat :**
        *   Si on passe l'ID : Le SDK l'envoie comme Token -> Rejet Serveur (`Invalid Match ID`).
        *   Si on passe le Token : Le Bridge stocke le Token comme ID. Quand le serveur renvoie le vrai ID, le Bridge ne reconna√Æt pas le match -> Connexion fant√¥me.

### Phase 2 : Repli sur Host/Join (Invitations)
*   **Objectif :** Contourner le Matchmaker. Le Host cr√©e un match, partage l'ID, le Client rejoint manuellement.
*   **Le Probl√®me :** Le "Bridge Amn√©sique".
    *   La connexion Socket fonctionne (les logs montrent `MatchJoin` r√©ussi).
    *   Cependant, le `NakamaMultiplayerBridge` ne parvient pas √† initialiser sa variable interne `_self_id`.
    *   Sans `_self_id`, le Bridge ne peut pas mapper les User IDs Nakama vers les Peer IDs Godot.
    *   **Tentatives de fix :** Injection manuelle des pr√©sences, for√ßage de la variable `_self_id` via `set()`, d√©lais d'attente.
    *   **R√©sultat :** `DEBUG: Bridge _self_id: <null>` persistant. Le Bridge est connect√© mais inerte.

## 3. Analyse Technique Profonde

Le probl√®me semble provenir de l'addon Godot Nakama lui-m√™me et de son interaction avec Godot 4 (GDScript 2.0).

1.  **Probl√®me de ClassDB (Godot 4) :** Comme not√© dans l'audit du 16/01, Godot perd parfois les r√©f√©rences aux classes globales des addons (`NakamaRTAPI`, etc.). Cela nous a oblig√©s √† faire des `preload` manuels et des instanciations "sales". Il est tr√®s probable que le Bridge √©choue silencieusement √† cause de cela en interne.
2.  **Design du SDK :** L'heuristique "Point = Token" dans le SDK Client est trop agressive et incompatible avec les IDs g√©n√©r√©s par le serveur Docker par d√©faut.
3.  **Opacit√© du Bridge :** Le `NakamaMultiplayerBridge` masque la complexit√© mais emp√™che le d√©bogage fin. Ses variables critiques (`_self_id`, `_peers_map`) sont priv√©es et semblent se r√©initialiser ou ne jamais s'assigner malgr√© nos tentatives de for√ßage.

## 4. Options pour la Suite

Nous ne pouvons pas continuer √† "bricoler" par-dessus une fondation instable. Voici les options :

### Option A : Demander de l'aide (Recommand√©)
Poster un rapport d√©taill√© sur le forum Heroic Labs. Le probl√®me est reproductible et semble structurel. (Voir template ci-dessous).

### Option B : Abandonner le Bridge (Hardcore)
Ne plus utiliser `NakamaMultiplayerBridge`.
*   Utiliser uniquement `NakamaSocket`.
*   √âcrire notre propre classe qui h√©rite de `MultiplayerPeerExtension` (tr√®s complexe) ou g√©rer la synchro manuellement sans les RPCs de haut niveau de Godot (en envoyant des messages JSON bruts via le socket).
*   *Co√ªt :* √âlev√© en temps de dev.

### Option C : Changer de Backend
Si Nakama s'av√®re trop instable avec Godot 4 pour l'instant :
*   Regarder du c√¥t√© de **W4 Games** (Cloud Godot officiel).
*   Ou revenir √† un serveur d√©di√© Godot simple (Headless) h√©berg√© sur un VPS, sans la couche Nakama.

---

## Annexe : Template pour demande d'aide (Forum)

**Title:** Godot 4 + Nakama: Bridge connects but peers list remains empty (Self ID null)

**Context:**
*   Godot 4.5.1
*   Nakama Docker (latest)
*   Official Nakama Godot SDK

**The Issue:**
I am trying to implement a simple Host/Join flow using `NakamaMultiplayerBridge`.
1.  Host creates a match -> Gets ID (e.g., `...e5e1.`).
2.  Client joins via `bridge.join_match(id)`.
3.  **Logs show success:** The socket connects, `MatchJoin` request resumes successfully, and `received_match_presence` events are fired on the socket.
4.  **The Bug:** `multiplayer.get_peers()` remains empty on both sides.

**Debugging:**
I inspected the bridge instance. It seems `_self_id` inside the bridge remains `<null>` or fails to initialize properly, preventing the bridge from mapping presences to Godot peers.
Even trying to force it via `bridge.set("_self_id", session.user_id)` before/after join doesn't seem to persist.

Also, I noticed that passing the Match ID (which ends in a dot `.`) causes the SDK to treat it as a Token due to the regex check in `join_match_async`.

**Code Snippet:**
```gdscript
nakama_bridge = NakamaMultiplayerBridge.new(socket)
nakama_bridge.match_joined.connect(_on_joined)
nakama_bridge.join_match(match_id)

# Result: _on_joined is called, but multiplayer.get_peers() is []
```
Has anyone successfully used the Bridge with Godot 4 recently?